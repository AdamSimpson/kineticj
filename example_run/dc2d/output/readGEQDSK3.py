#### wrapped versionimport reimport numpy as nimport pylab as pclass eqdskClass:    def __init__(self):        self.r = []        self.z = []        self.psizr = []        self.rbbbs = []        self.zbbbs = []        self.rlim = []        self.zlim = []    ### can have an overloaded __init__ constructor, as in __init__(self, filename) ?    def readGEQDSK3(self,filename):    #   Try reading g-eqdsk file with re (regex) module    #   instead of the non-existant fortran format code    #   python feature.    #   WARNING: this code has only been testing on the    #   two files listed below and my regex skills are    #   quite poor (as is my python ) so you have been    #   warned.    #   DLG - 14-Aug-08    #   JCW - 27-Jan-10    # some improvements to regular expression and implemented direct casting    # of string arrays to floating arrays.    # Regexp are a bit fragile here. Should take advantage of the known data    # ordering with n.fromfile    #file=open('/home/jwright/mnt/loki/Codes/ACCOME/RUNS/Alcator-C/B/NewEQDSK/eqdsk.dat')    #file = open('/Users/dvk/scratch/aorsa2d/nstx_March30_2015/nstx_dfactor0_25/input/NSTX_130608A03_trxpl_0.410_plasma_state.geq')        file = open(filename)    #file=open('/home/jwright/Codes/trunk/tests/Test1/g019314.T06500')    #file = open ('eqdsk.dat')    #'/home/jwright/Codes/TORIC_RUNS/109.1/Mapping/g1060728011.01100'    #file    = open ( 'g103875.nstx' )    #file    = open ( 'g129x129_1051206002.01120.cmod' )        data    = file.read ()        dimensionsRE    = re.compile ( ' {1,3}\d?\d?\d?\d\d' ) # Equivalent to i5 fortran code, JCW these should be i4        dimensionsRE5    = re.compile ( ' {1,3}\d?\d?\d?\d' ) # Equivalent to i5 fortran code        headerRE    = re.compile ( '^.*\\n') # First line        valuesRE   = re.compile ( '([ \-]\d\.\d{9}E[\+\-]\d\d)' )   # Equivalent to e16.9 fortran code        #bbbsRE  = re.compile ( '( {1,3}\d?\d?\d?\d\d {1,3}\d?\d?\d?\d\d)' )   # Candidate dimension lines (2i5 fortran code)        bbbsRE  = re.compile ( r'(?m)^.{10}\n' ) #there should be only one 10 character line        dataStr     = valuesRE.findall ( data )        headerStr   = headerRE.findall ( data )        bbbStr  = bbbsRE.findall ( data )        file.close ()        #  Scalars        nWnHStr = dimensionsRE.findall ( headerStr[0] )        nbbbsStr    = dimensionsRE5.findall ( bbbStr[0] )        nW  = n.int ( nWnHStr[-2] )        nH  = n.int ( nWnHStr[-1] )        nbbbs   = n.int ( nbbbsStr[-2] )        limitr   = n.int( nbbbsStr[-1] )        rdim    = n.float ( dataStr[0] )        zdim    = n.float ( dataStr[1] )        rcentr  = n.float ( dataStr[2] )        rleft   = n.float ( dataStr[3] )        zmid    = n.float ( dataStr[4] )        rmaxis  = n.float ( dataStr[5] )        zmaxis  = n.float ( dataStr[6] )        simag   = n.float ( dataStr[7] )        sibry   = n.float ( dataStr[8] )        bcentr  = n.float ( dataStr[9] )        current = n.float ( dataStr[10] )                #   1D n.arrays        offset=20        fpol   = n.array(dataStr[offset:(offset+nW)],dtype='float')        offset=offset+nW        pres   = n.array(dataStr[offset:(offset+nW)],dtype='float')        offset=offset+nW        ffprim = n.array(dataStr[offset:(offset+nW)],dtype='float')        offset=offset+nW        pprime = n.array(dataStr[offset:(offset+nW)],dtype='float')        #   2D n.array        offset=offset+nW        psizr = n.reshape(n.array(dataStr[offset:(offset+nW*nH)],dtype='float'),(nH,nW))        #more 1D n.arrays        offset=offset+nW*nH        qpsi   = n.array(dataStr[offset:(offset+nW)],dtype='float')        offset=offset+nW        rzbbbs = n.array(dataStr[offset:(offset+2*nbbbs)],dtype='float')        rbbbs = rzbbbs[::2]        zbbbs = rzbbbs[1::2]        offset=offset+2*nbbbs        rzlim = n.array(dataStr[offset:(offset+2*limitr)],dtype='float')        rlim = rzlim[::2]        zlim = rzlim[1::2]        ##Done processing geqdsk file.        #generate spatial and flux coordinates        rStep   = rdim / ( nW - 1 )        zStep   = zdim / ( nH - 1 )        fStep   = -( simag - sibry ) / ( nW - 1 )        r   = n.arange ( nW ) * rStep + rleft        z   = n.arange ( nH ) * zStep + zmid - zdim / 2.0        fluxGrid    = n.arange ( nW ) * fStep + simag        #   Find indices of points inside and outside        #   the rbbbs/zbbbs boundary.        iiInsideA   = n.zeros ( psizr.shape, dtype=bool )        poly = [(rzbbbs[i],rzbbbs[i+1]) for i in range(nbbbs-1)]        for i in n.arange ( nW ) :            for j in n.arange ( nH ) :                 q1  = n.size ( n.where ( ( r[i] - rbbbs > 0 ) & ( z[j] - zbbbs > 0 ) ) )                 q2  = n.size ( n.where ( ( r[i] - rbbbs > 0 ) & ( z[j] - zbbbs <= 0 ) ) )                 q3  = n.size ( n.where ( ( r[i] - rbbbs <= 0 ) & ( z[j] - zbbbs > 0 ) ) )                 q4  = n.size ( n.where ( ( r[i] - rbbbs <= 0 ) & ( z[j] - zbbbs <= 0 ) ) )                 iiInsideA[i,j] = ( q1 > 0 ) & ( q2 > 0 ) & ( q3 > 0 ) & ( q4 > 0 )        iiInside    = n.where ( iiInsideA != 0 )        iiOutside   = n.where ( iiInsideA == 0 )        self.r = r        self.z = z        self.psizr = psizr        self.rbbbs = rbbbs        self.zbbbs = zbbbs        self.rlim = rlim        self.zlim = zlim        return None    #return r, z, psizr, rbbbs, zbbbs, rlim, zlim    #print nW, nH, nbbbs, limitr    #print rdim, zdim, rcentr, rleft, zmid    #print rmaxis, zmaxis, simag, sibry, bcentr    #   Plot output    #p.contourf ( r, z, psizr, 20 )    #p.plot ( rbbbs, zbbbs, 'k', linewidth = 2 )    #p.plot ( rlim, zlim, 'k', linewidth = 1 )    #p.show ()